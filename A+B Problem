题目描述
高精度加法，相当于a+b problem，不用考虑负数.

输入格式
分两行输入。a,b \leq 10^{500}a,b≤10 
500
 

输出格式
输出只有一行，代表a+ba+b的值

输入输出样例
输入 #1复制
1
1
输出 #1复制
2
输入 #2复制
1001
9099
输出 #2复制
10100

//by myself
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int main() {
	char num1[505] = { '\0' };
	char num2[505] = { '\0' };
	cin >> num1 >> num2;
	int len1 = strlen(num1);
	int len2 = strlen(num2);
	int len = max(len1, len2);
	char temp1[505] = { '\0' };
	char temp2[505] = { '\0' };
	char temp3[505] = { '\0' };
	for (int i = 0; i < len1; i++) {
		temp1[i] = num1[len1 - 1 - i];
	}
	for (int i = 0; i < len2; i++) {
		temp2[i] = num2[len2 - 1 - i];
	}
	for (int i = 0; i < len; i++) {
		if (temp1[i] == '\0') {
			temp1[i] = '0';
		}
		if (temp2[i] == '\0') {
			temp2[i] = '0';
		}
	}
	for (int i = 0; i <= len; i++) {
		temp3[i] = '0';
	}
	for (int i = 0; i < len; i++) {
		int temp = temp1[i] - '0' + temp2[i] - '0';
		if (temp3[i] == '1') {
			if (temp > 9) {
				temp3[i] += (temp % 10);
				temp3[i + 1] = '1';
			}
			else if (temp == 9) {
				temp3[i] = '0';
				temp3[i + 1] = '1';
			}
			else {
				temp3[i] += temp;
			}
		}
		else {
			if (temp == 10) {
				temp3[i + 1] += 1;
			}
			else if (temp > 10) {
				temp3[i] += (temp % 10);
				temp3[i + 1] += 1;
			}
			else if (temp >= 0 && temp < 10) {
				temp3[i] += temp;
			}
		}
	}
	if (temp3[len] == '0') {
		temp3[len] = '\0';
	}
	char num3[505] = { '\0' };
	int len3 = strlen(temp3);
	for (int i = 0; i < len3; i++) {
		num3[i] = temp3[len3 - 1 - i];
	}
	cout << num3 << endl;
	return 0;
}

//by Callous_Murder from www.luogu.com.cn/problem/solution/P1601
#include<bits/stdc++.h>
using namespace std;
int a[1000001],b[1000001],c[1000001],j;
bool x=false;
char s[1000001],ss[1000001];
int main() {

	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));//初始化
	scanf("%s%s",s,ss);//读入两个数
	a[0]=strlen(s);
	b[0]=strlen(ss);//获取长度
	for(int i=1; i<=a[0]; i++) a[i]=s[a[0]-i]-'0';
	for(int i=1; i<=b[0]; i++) b[i]=ss[b[0]-i]-'0';//转化为数字
	for(j=1; j<=max(a[0],b[0])+1; j++) {
		c[j]=a[j]+b[j];
		if(c[j]>=10) {
			c[j]%=10;
			a[j+1]++;
		}
	}//模拟加法
	c[0]=j;
	if(c[j+1]>0) c[0]++;//特判进位
	for(int i=c[0]; i>=1; i--) {//输出（删除前导零）
		if(x==false&&c[i]==0) continue;
		x=true;
		cout<<c[i];
	}
	if(x==false) cout<<0;//一重保险
	printf("\n");//二重保险
	return 0;//三重保险
}
