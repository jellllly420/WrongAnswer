题目 - 拼装模型	
描述
Dzx从日本回来了，并为TN准备了礼物----一个恐龙模型。TN想把它尽快拼好，但是由于模型很庞大，TN又实在比较懒，所以他希望你为他寻找一个最节省时间的拼装方案。

模型是由N个零件组成的，每次TN可以选取两个零件拼装在一起来组成一个新的零件，直到得到完整的模型。由于零件的复杂程度不同，TN每次拼装所需要的时间也是不同的，对于两个零件A和B，假设他们的复杂程度分别为a和b，则TN要将这两个零件拼装在一起所需要的时间为a+b，而这由两个零件所组成的新零件的复杂程度为a+b。

现在TN已经统计出了每个零件的复杂程度，你能告诉他最快的拼装方法需要多少时间么？
关于输入
Line 1： N (1 <= N <= 10000)，零件数目
Line 2： N Integers，表示每个零件的复杂程度
关于输出
最快的拼装方案所需要的时间
例子输入
3

1 2 9
例子输出
15
提示
每次都选择当前最小的两个零件。

#include<iostream>
using namespace std;
int com[10005] = { 0 };
int main() {
	int n = 0;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> com[i];
	}
	for (int i = 0; i < n - 1; i++) {
		for (int j = 0; j < n - 1 - i; j++) {
			if (com[j] > com[j + 1]) {
				int temp = com[j];
				com[j] = com[j + 1];
				com[j + 1] = temp;
			}
		}
	}
	int total = 0;
	for (int i = 0; i < n - 1; i++) {
		com[i + 1] += com[i];
		total += com[i + 1];
		/*
		for (int j = i + 1; j < n - 2; j++) {
			for (int t = i + 1; t < n  - j+i; t++) {
				if (com[t] > com[t + 1]) {
					int temp = com[t];
					com[t] = com[t + 1];
					com[t + 1] = temp;
				}
			}
		}
		*/
		if (i + 1 == n - 2) {
			if (com[i + 1] > com[n - 1]) {
				int temp = com[i + 1];
				com[i + 1] = com[n - 1];
				com[n - 1] = temp;
			}
		}
		else {
			int flag = 0;
			int haha = com[i + 1];
			if (com[i + 1] <= com[i + 2]) {
				continue;
			}
			else {
				for (int j = i + 2; j < n; j++) {
					if (com[i + 1] <= com[j]) {
						for (int t = i + 1; t < j - 1; t++) {
							com[t] = com[t + 1];
						}
						com[j - 1] = haha;
						flag = 1;
						break;
					}
				}
				if (flag == 0) {
					for (int j = i + 1; j < n - 1; j++) {
						com[j] = com[j + 1];
					}
					com[n - 1] = haha;
				}
			}
		}
	}
	cout << total << endl;
	return 0;
}
