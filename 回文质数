题目描述
因为 151 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 151 是回文质数。

写一个程序来找出范围 [a,b] (5 \le a < b \le 100,000,000)[a,b](5≤a<b≤100,000,000)( 一亿)间的所有回文质数。

输入格式
第 1 行: 二个整数 a 和 b .

输出格式
输出一个回文质数的列表，一行一个。

输入输出样例
输入 #1复制
5 500
输出 #1复制
5
7
11
101
131
151
181
191
313
353
373
383
说明/提示
Hint 1: Generate the palindromes and see if they are prime.

提示 1: 找出所有的回文数再判断它们是不是质数（素数）.

Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.

提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。

题目翻译来自NOCOW。

USACO Training Section 1.5

产生长度为5的回文数:

for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
     for (d2 = 0; d2 <= 9; d2++) {
         for (d3 = 0; d3 <= 9; d3++) {
           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)
         }
     }
 }
 
 
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int a = 0, b = 0;
int confirm(int num) {
	int ans = 1;
	while (num / 10 != 0) {
		ans++;
		num /= 10;
	}
	return ans;
}
int mark[10000000] = { 0 };
void is_Prime(int max) {
	memset(mark, 1, sizeof(mark));
	mark[1] = 0;
	for (int i = 2; i * i < max; i++) {
		if (mark[i]) {
			for (int j = i * 2; j < max; j += i) {
				mark[j] = 0;;
			}
		}
	}
	return;
}
void opreate(int len) {
	switch (len) {
	case 1: {
		for (int i = a; i < 10; i++) {
			if (i > b) {
				break;
			}
			if (mark[i]) {
				cout << i << endl;
			}
		}
		break;
	}
	case 2:cout << 11 << endl; break;
	case 3: {
		int num = 0;
		for (int d1 = 1; d1 <= 9; d1 += 2) {
			for (int d2 = 0; d2 <= 9; d2++) {
				num = 100 * d1 + 10 * d2 + d1;
				if (num < a) {
					continue;
				}
				if (num > b) {
					break;
				}
				if (mark[num]) {
					cout << num << endl;
				}
			}
		}
		break;
	}
	case 5: {
		int num = 0;
		for (int d1 = 1; d1 <= 9; d1 += 2) {
			for (int d2 = 0; d2 <= 9; d2++) {
				for (int d3 = 0; d3 <= 9; d3++) {
					num = 10000 * d1 + 1000 * d2 + 100 * d3 + 10 * d2 + d1;
					if (num < a) {
						continue;
					}
					if (num > b) {
						break;
					}
					if (mark[num]) {
						cout << num << endl;
					}
				}
			}
		}
		break;
	}
	case 7: {
		int num = 0;
		for (int d1 = 1; d1 <= 9; d1 += 2) {
			for (int d2 = 0; d2 <= 9; d2++) {
				for (int d3 = 0; d3 <= 9; d3++) {
					for (int d4 = 0; d4 <= 9; d4++) {
						num = 1000000 * d1 + 100000 * d2 + 10000 * d3 + 1000 * d4 + 100 * d3 + 10 * d2 + d1;
						if (num < a) {
							continue;
						}
						if (num > b) {
							break;
						}
						if (mark[num]) {
							cout << num << endl;
						}
					}
				}
			}
		}
		break;
	}
	default:break;
	}
	return;
}
int main() {
	cin >> a >> b;
	if (b >= 10000000) {
		b = 9999999;
	}
	int minlen = confirm(a);
	int maxlen = confirm(b);
	is_Prime((int)pow(10, maxlen));
	for (int i = minlen; i <= maxlen; i++) {
		opreate(i);
	}
	return 0;
}
