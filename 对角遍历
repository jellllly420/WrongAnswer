题目 - 对角遍历	
来源	计算概论B2020(孙俊)-黄志杰-难
描述
阿福最近在研究矩阵的遍历。给定一个大小为4nx4n的方阵，现在需要将序号0-4nx4n-1依次放入到方阵中。放置方式具体如下：
首先，将4nx4n分成16个4n-1x4n-1的子块，然后按照对角遍历的方式（如下图所示）遍历各个子块；对于每个子块继续划分成16个更小的子块，并按照如下图所示的方式遍历各个子块，..., 以此类推，并将遍历的顺序号依次填入各个1x1方块中。

现在给定非负整数n，一个1x1方块的行号x和列号y,其中0<=x,y<4n,请求出该块遍历的序号。输入保证1<=n<=10。
关于输入
包含多行，每行三个非负整数n,x,y,中间用空格隔开
当n为0时，表示输入结束,该组输入不用处理
关于输出
输出包括多行，每行一个整数，表示输入块按照上述遍历方式得到的序号。
例子输入
2 3 3

4 4 4

5 12 9

0 1 2
例子输出
15

64

210

#include<iostream>
#include<cmath>
using namespace std;

int main() {
	int n = 0;
	while (cin >> n) {
		if (n == 0) {
			break;
		}
		int x = 0, y = 0;
		cin >> x >> y;
		int num = 0;
		int pos = 0;
		for (int i = n - 1; i >= 0; i--) {
			int state = pow(4.0, i);
			int now_x = x / state;
			int now_y = y / state;
			if (now_x == 0) {
				if (now_y == 0) {
					pos = 0;
				}
				else if (now_y == 1) {
					pos = 2;
				}
				else if (now_y == 2) {
					pos = 5;
				}
				else {
					pos = 9;
				}
			}
			else if (now_x == 1) {
				if (now_y == 0) {
					pos = 1;
				}
				else if (now_y == 1) {
					pos = 4;
				}
				else if (now_y == 2) {
					pos = 8;
				}
				else {
					pos = 12;
				}
			}
			else if (now_x == 2) {
				if (now_y == 0) {
					pos = 3;
				}
				else if (now_y == 1) {
					pos = 7;
				}
				else if (now_y == 2) {
					pos = 11;
				}
				else {
					pos = 14;
				}
			}
			else {
				if (now_y == 0) {
					pos = 6;
				}
				else if (now_y == 1) {
					pos = 10;
				}
				else if (now_y == 2) {
					pos = 13;
				}
				else {
					pos = 15;
				}
			}
			x = x - now_x*state;
			y = y - now_y*state;
			num += pos * state * state;
		}
		cout << num << endl;
	}
	return 0;
}
